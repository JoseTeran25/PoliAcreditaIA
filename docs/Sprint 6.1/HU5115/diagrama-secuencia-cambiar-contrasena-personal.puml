@startuml diagrama-secuencia-cambiar-contrasena-personal
!theme plain
skinparam backgroundColor #FFFFFF
skinparam sequenceParticipantBorderColor #2E5C8B
skinparam sequenceActorBorderColor #2E5C8B
skinparam sequenceActorBackgroundColor #E8F4FD
skinparam sequenceParticipantBackgroundColor #E8F4FD
skinparam sequenceMessageTextSize 11
skinparam sequenceActorFontSize 11
skinparam sequenceParticipantFontSize 11

title HU5115: Cambiar ContraseÃ±a Personal del Usuario

actor "Usuario\nAutenticado" as user
participant "Frontend\n(Cliente)" as frontend
participant "Auth Guard\n(JWT)" as auth
participant "UsuariosController" as controller
participant "ValidationPipe" as validator
participant "UsuariosService" as service
participant "UsuarioModel\n(Sequelize)" as model
participant "bcrypt\n(Hashing)" as bcrypt
database "PostgreSQL\nDatabase" as db

== Caso Exitoso: Cambio de ContraseÃ±a ==

user -> frontend: PUT /me/password\n{\n  "contrasenaActual": "MiContraseÃ±a123!",\n  "contrasenaNueva": "NuevaSegura456#",\n  "confirmarContrasena": "NuevaSegura456#"\n}
activate frontend

frontend -> auth: Verificar token JWT
activate auth
auth -> auth: Validar token y usuario activo
auth --> frontend: Token vÃ¡lido, usuario autenticado
deactivate auth

frontend -> controller: PUT /me/password + user context
activate controller

controller -> validator: Validar ChangePasswordDto
activate validator
validator -> validator: @IsNotEmpty() contrasenaActual\n@MinLength(8) contrasenaNueva\n@Matches(regex) contrasenaNueva
validator --> controller: âœ… Validaciones exitosas
deactivate validator

controller -> service: changePassword(userId, changePasswordDto)
activate service

service -> service: Verificar contraseÃ±as coinciden
service -> service: contrasenaNueva === confirmarContrasena
service -> service: âœ… ContraseÃ±as coinciden

service -> model: findByPk(userId)
activate model
model -> db: SELECT * FROM usuarios WHERE id = userId
activate db
db --> model: Usuario encontrado
deactivate db
model --> service: UsuarioModel instance
deactivate model

service -> service: Verificar usuario activo
service -> service: âœ… usuario.estadoActivo === true

service -> model: usuario.validatePassword(contrasenaActual)
activate model
model -> bcrypt: bcrypt.compare(contrasenaActual, hashedPassword)
activate bcrypt
bcrypt --> model: âœ… ContraseÃ±a vÃ¡lida
deactivate bcrypt
model --> service: true
deactivate model

service -> model: usuario.validatePassword(contrasenaNueva)
activate model
model -> bcrypt: bcrypt.compare(contrasenaNueva, hashedPassword)
activate bcrypt
bcrypt --> model: âœ… ContraseÃ±a diferente
deactivate bcrypt
model --> service: false (contraseÃ±a diferente)
deactivate model

service -> model: usuario.update({contrasena: contrasenaNueva})
activate model
model -> model: Hook beforeUpdate activado
model -> bcrypt: genSalt(12)
activate bcrypt
bcrypt --> model: Salt generado
deactivate bcrypt
model -> bcrypt: hash(contrasenaNueva, salt)
activate bcrypt
bcrypt --> model: ContraseÃ±a hasheada
deactivate bcrypt
model -> db: UPDATE usuarios SET contrasena = hashedPassword\nWHERE id = userId
activate db
db --> model: ContraseÃ±a actualizada
deactivate db
model --> service: ActualizaciÃ³n exitosa
deactivate model

service --> controller: {message: "ContraseÃ±a actualizada exitosamente"}
deactivate service

controller --> frontend: 200 OK\n{\n  "message": "ContraseÃ±a actualizada exitosamente"\n}
deactivate controller

frontend --> user: âœ… ContraseÃ±a cambiada exitosamente
deactivate frontend

== Caso de Error: ContraseÃ±a Actual Incorrecta ==

user -> frontend: PUT /me/password\n{\n  "contrasenaActual": "ContraseÃ±aIncorrecta",\n  "contrasenaNueva": "NuevaSegura456#",\n  "confirmarContrasena": "NuevaSegura456#"\n}
activate frontend

frontend -> auth: Verificar token JWT
activate auth
auth --> frontend: Token vÃ¡lido
deactivate auth

frontend -> controller: PUT /me/password
activate controller

controller -> validator: Validar datos
activate validator
validator --> controller: Datos vÃ¡lidos
deactivate validator

controller -> service: changePassword(userId, changePasswordDto)
activate service

service -> service: Verificar contraseÃ±as coinciden
service -> service: âœ… ContraseÃ±as nuevas coinciden

service -> model: findByPk(userId)
activate model
model --> service: Usuario encontrado
deactivate model

service -> model: usuario.validatePassword(contrasenaActual)
activate model
model -> bcrypt: bcrypt.compare("ContraseÃ±aIncorrecta", hashedPassword)
activate bcrypt
bcrypt --> model: âŒ ContraseÃ±a invÃ¡lida
deactivate bcrypt
model --> service: false
deactivate model

service -> service: throw BadRequestException
service --> controller: âŒ La contraseÃ±a actual es incorrecta
deactivate service

controller --> frontend: 400 Bad Request\n{\n  "statusCode": 400,\n  "message": "La contraseÃ±a actual es incorrecta",\n  "error": "Bad Request"\n}
deactivate controller

frontend --> user: âŒ Error: ContraseÃ±a actual incorrecta
deactivate frontend

== Caso de Error: PolÃ­tica de Seguridad No Cumplida ==

user -> frontend: PUT /me/password\n{\n  "contrasenaActual": "MiContraseÃ±a123!",\n  "contrasenaNueva": "123",\n  "confirmarContrasena": "123"\n}
activate frontend

frontend -> auth: Verificar token JWT
activate auth
auth --> frontend: Token vÃ¡lido
deactivate auth

frontend -> controller: PUT /me/password
activate controller

controller -> validator: Validar ChangePasswordDto
activate validator
validator -> validator: @MinLength(8) contrasenaNueva\nâŒ "123" < 8 caracteres
validator -> validator: @Matches(regex) contrasenaNueva\nâŒ No cumple complejidad
validator --> controller: âŒ ValidationError
deactivate validator

controller --> frontend: 400 Bad Request\n{\n  "statusCode": 400,\n  "message": [\n    "La nueva contraseÃ±a debe tener al menos 8 caracteres",\n    "La nueva contraseÃ±a debe contener al menos: una letra minÃºscula, una mayÃºscula, un nÃºmero y un carÃ¡cter especial"\n  ],\n  "error": "Bad Request"\n}
deactivate controller

frontend --> user: âŒ Error: ContraseÃ±a no cumple polÃ­ticas
deactivate frontend

== Caso de Error: ContraseÃ±as No Coinciden ==

user -> frontend: PUT /me/password\n{\n  "contrasenaActual": "MiContraseÃ±a123!",\n  "contrasenaNueva": "NuevaSegura456#",\n  "confirmarContrasena": "DiferenteContraseÃ±a789$"\n}
activate frontend

frontend -> auth: Verificar token JWT
activate auth
auth --> frontend: Token vÃ¡lido
deactivate auth

frontend -> controller: PUT /me/password
activate controller

controller -> validator: Validar datos individualmente
activate validator
validator --> controller: Cada campo vÃ¡lido por separado
deactivate validator

controller -> service: changePassword(userId, changePasswordDto)
activate service

service -> service: Verificar contraseÃ±as coinciden
service -> service: contrasenaNueva !== confirmarContrasena
service -> service: throw BadRequestException
service --> controller: âŒ Las contraseÃ±as no coinciden
deactivate service

controller --> frontend: 400 Bad Request\n{\n  "statusCode": 400,\n  "message": "La nueva contraseÃ±a y la confirmaciÃ³n no coinciden",\n  "error": "Bad Request"\n}
deactivate controller

frontend --> user: âŒ Error: ContraseÃ±as no coinciden
deactivate frontend

== Caso de Error: Nueva ContraseÃ±a Igual a la Actual ==

user -> frontend: PUT /me/password\n{\n  "contrasenaActual": "MiContraseÃ±a123!",\n  "contrasenaNueva": "MiContraseÃ±a123!",\n  "confirmarContrasena": "MiContraseÃ±a123!"\n}
activate frontend

frontend -> auth: Verificar token JWT
activate auth
auth --> frontend: Token vÃ¡lido
deactivate auth

frontend -> controller: PUT /me/password
activate controller

controller -> validator: Validar datos
activate validator
validator --> controller: Datos vÃ¡lidos
deactivate validator

controller -> service: changePassword(userId, changePasswordDto)
activate service

service -> service: Verificar contraseÃ±as coinciden
service -> service: âœ… ContraseÃ±as nuevas coinciden

service -> model: findByPk(userId)
activate model
model --> service: Usuario encontrado
deactivate model

service -> model: usuario.validatePassword(contrasenaActual)
activate model
model -> bcrypt: bcrypt.compare(contrasenaActual, hashedPassword)
activate bcrypt
bcrypt --> model: âœ… ContraseÃ±a vÃ¡lida
deactivate bcrypt
model --> service: true
deactivate model

service -> model: usuario.validatePassword(contrasenaNueva)
activate model
model -> bcrypt: bcrypt.compare(contrasenaNueva, hashedPassword)
activate bcrypt
bcrypt --> model: âŒ Misma contraseÃ±a
deactivate bcrypt
model --> service: true (misma contraseÃ±a)
deactivate model

service -> service: throw BadRequestException
service --> controller: âŒ Nueva contraseÃ±a debe ser diferente
deactivate service

controller --> frontend: 400 Bad Request\n{\n  "statusCode": 400,\n  "message": "La nueva contraseÃ±a debe ser diferente a la actual",\n  "error": "Bad Request"\n}
deactivate controller

frontend --> user: âŒ Error: ContraseÃ±a debe ser diferente
deactivate frontend

note over user, db
  **CaracterÃ­sticas de Seguridad de la HU5115:**
  
  ğŸ” **AutenticaciÃ³n**: Solo usuarios autenticados pueden cambiar su contraseÃ±a
  ğŸ›¡ï¸ **VerificaciÃ³n de identidad**: Requiere contraseÃ±a actual correcta
  ğŸ“ **PolÃ­ticas de complejidad**: MÃ­nimo 8 caracteres con mayÃºsculas, minÃºsculas, nÃºmeros y sÃ­mbolos
  ğŸ”’ **Hashing seguro**: bcrypt con salt de 12 rounds para almacenamiento
  âœ… **ValidaciÃ³n doble**: ConfirmaciÃ³n de contraseÃ±a para evitar errores de tipeo
  ğŸš« **Anti-reutilizaciÃ³n**: Previene usar la misma contraseÃ±a actual
  ğŸ”„ **Hooks automÃ¡ticos**: El modelo se encarga del hashing transparentemente
  
  **Casos de uso principales:**
  â€¢ Cambio rutinario de contraseÃ±a por seguridad
  â€¢ Respuesta ante sospecha de compromiso de cuenta
  â€¢ Cumplimiento de polÃ­ticas de seguridad institucional
  â€¢ RecuperaciÃ³n de cuenta comprometida
end note

@enduml